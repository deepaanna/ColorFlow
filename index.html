<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Color Flow - Connect the Colors</title>
    
    <!-- Google AdSense (Replace with your ID) -->
    <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-YOUR_ID" crossorigin="anonymous"></script> -->
    
    <link rel="manifest" href="./manifest.json">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --bg-dark: #1a1a2e;
            --bg-medium: #16213e;
            --text: #ffffff;
            --text-dim: #b8b8d1;
            --success: #4facfe;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }

        .game-container {
            width: 100%;
            max-width: 450px;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header {
            text-align: center;
            padding: 20px 0;
        }

        .game-title {
            font-size: 36px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 14px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            gap: 10px;
        }

        .stat-card {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--text);
            margin-top: 5px;
        }

        .game-board {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 12px;
            margin: 20px 0;
        }

        .grid {
            display: grid;
            gap: 3px;
        }

        .cell {
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            background: var(--bg-medium);
            border: 2px solid transparent;
            transition: all 0.2s ease;
            position: relative;
        }

        .cell:not(.source):not(.filled):hover {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.08);
        }

        .cell.source {
            cursor: default;
            border-color: rgba(255, 255, 255, 0.3);
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .cell.filled {
            animation: fillPop 0.3s ease;
        }

        @keyframes fillPop {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .color-palette {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s ease;
            position: relative;
        }

        .color-btn:hover {
            transform: translateY(-3px) scale(1.1);
        }

        .color-btn.selected {
            border-color: white;
            transform: scale(1.1);
        }

        .color-btn.selected::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        .btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            color: white;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            transition: all 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Success Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-medium);
            border-radius: 20px;
            padding: 30px;
            max-width: 350px;
            width: 100%;
            text-align: center;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-title {
            font-size: 28px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, var(--success) 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .modal-text {
            color: var(--text-dim);
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
        }

        /* Support Button */
        .support-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .support-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.15);
        }

        /* Ad Banner Space */
        .ad-banner {
            width: 100%;
            max-width: 450px;
            height: 60px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            font-size: 12px;
            margin: 20px 0;
        }

        /* Hint animation */
        .cell.hint {
            animation: hintGlow 0.6s ease 2;
        }

        @keyframes hintGlow {
            0%, 100% { box-shadow: 0 0 0 rgba(79, 172, 254, 0); }
            50% { box-shadow: 0 0 20px rgba(79, 172, 254, 0.8); }
        }

        /* Mobile optimizations */
        @media (max-width: 480px) {
            .game-title { font-size: 28px; }
            .color-btn { width: 45px; height: 45px; }
            .btn { padding: 12px; font-size: 14px; }
        }

        /* Premium themes (unlockable) */
        body.theme-sunset {
            --primary: #FF6B6B;
            --secondary: #4ECDC4;
        }

        body.theme-ocean {
            --primary: #4facfe;
            --secondary: #00f2fe;
        }

        body.theme-forest {
            --primary: #11998e;
            --secondary: #38ef7d;
        }
    </style>
</head>
<body>
    <!-- Optional Ad Banner (only shows if AdSense is configured) -->
    <div class="ad-banner" id="topAd">
        <!-- Ad space - Configure AdSense to show here -->
        <span>Advertisement Space</span>
    </div>

    <div class="game-container">
        <div class="header">
            <h1 class="game-title">COLOR FLOW</h1>
            <p class="subtitle">Connect all the colors!</p>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">Level</div>
                <div class="stat-value" id="level">1</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Moves</div>
                <div class="stat-value" id="moves">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Hints</div>
                <div class="stat-value" id="hints">3</div>
            </div>
        </div>

        <div class="game-board">
            <div class="grid" id="grid"></div>
        </div>

        <div class="color-palette" id="colorPalette"></div>

        <div class="controls">
            <button class="btn" id="hintBtn" onclick="game.useHint()">
                ðŸ’¡ Hint (<span id="hintCount">3</span>)
            </button>
            <button class="btn" onclick="game.reset()">
                ðŸ”„ Reset
            </button>
        </div>
    </div>

    <!-- Support Button -->
    <button class="support-btn" onclick="openSupport()" title="Support the Developer">
        â˜•
    </button>

    <!-- Level Complete Modal -->
    <div class="modal" id="successModal">
        <div class="modal-content">
            <h2 class="modal-title">Level Complete!</h2>
            <p class="modal-text">
                Great job! You solved it in <span id="modalMoves">0</span> moves!
                <br><br>
                <small id="rewardText" style="display: none; color: var(--success);">
                    Watch an ad for +2 hints? 
                </small>
            </p>
            <div class="modal-buttons">
                <button class="btn" id="watchAdBtn" style="display: none;" onclick="watchAd()">
                    ðŸ“º Watch Ad (+2 Hints)
                </button>
                <button class="btn" onclick="nextLevel()">
                    Next Level â†’
                </button>
            </div>
        </div>
    </div>

    <script>
        // Simple Color Flow Game Implementation
        class ColorFlowGame {
            constructor() {
                this.gridSize = 6;
                this.level = 1;
                this.moves = 0;
                this.hints = 3;
                this.maxHints = 5;
                this.grid = [];
                this.sources = [];
                this.selectedColor = null;
                this.isComplete = false;
                
                // Color schemes
                this.colorSchemes = [
                    ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'],
                    ['#F7DC6F', '#82E0AA', '#85C1E2', '#BB8FCE'],
                    ['#F8B739', '#FF6B9D', '#C44569', '#2C73D2'],
                    ['#845EC2', '#D65DB1', '#FF6F91', '#FF9671']
                ];
                
                this.currentColors = this.colorSchemes[0];
                this.init();
            }
            
            init() {
                this.loadProgress();
                this.generateLevel();
                this.render();
                this.updateStats();
            }
            
            loadProgress() {
                const saved = localStorage.getItem('colorflow_progress');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.level = data.level || 1;
                    this.hints = data.hints || 3;
                }
            }
            
            saveProgress() {
                localStorage.setItem('colorflow_progress', JSON.stringify({
                    level: this.level,
                    hints: this.hints
                }));
            }
            
            generateLevel() {
                // Adjust difficulty based on level
                const numColors = Math.min(3 + Math.floor(this.level / 5), 5);
                const gridSize = Math.min(6 + Math.floor(this.level / 10), 10);
                this.gridSize = gridSize;
                
                // Pick random color scheme
                this.currentColors = this.colorSchemes[this.level % this.colorSchemes.length];
                
                // Initialize empty grid
                this.grid = Array(this.gridSize).fill(null).map(() => 
                    Array(this.gridSize).fill(null)
                );
                
                this.sources = [];
                
                // Place color sources
                for (let i = 0; i < numColors; i++) {
                    let placed = false;
                    while (!placed) {
                        const x = Math.floor(Math.random() * this.gridSize);
                        const y = Math.floor(Math.random() * this.gridSize);
                        
                        if (!this.grid[y][x]) {
                            this.grid[y][x] = {
                                color: this.currentColors[i],
                                isSource: true,
                                sourceId: i
                            };
                            this.sources.push({ x, y, color: this.currentColors[i], id: i });
                            
                            // Place matching end point
                            let endPlaced = false;
                            let attempts = 0;
                            while (!endPlaced && attempts < 100) {
                                const ex = Math.floor(Math.random() * this.gridSize);
                                const ey = Math.floor(Math.random() * this.gridSize);
                                
                                // Ensure some distance between source and end
                                const distance = Math.abs(ex - x) + Math.abs(ey - y);
                                if (!this.grid[ey][ex] && distance >= 3) {
                                    this.grid[ey][ex] = {
                                        color: this.currentColors[i],
                                        isSource: true,
                                        sourceId: i
                                    };
                                    this.sources.push({ x: ex, y: ey, color: this.currentColors[i], id: i });
                                    endPlaced = true;
                                }
                                attempts++;
                            }
                            placed = true;
                        }
                    }
                }
                
                this.moves = 0;
                this.isComplete = false;
            }
            
            render() {
                const gridEl = document.getElementById('grid');
                gridEl.innerHTML = '';
                gridEl.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;
                
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        
                        const cellData = this.grid[y][x];
                        if (cellData) {
                            if (cellData.isSource) {
                                cell.classList.add('source');
                                cell.textContent = cellData.sourceId + 1;
                            } else {
                                cell.classList.add('filled');
                            }
                            cell.style.background = cellData.color;
                        }
                        
                        cell.onclick = () => this.handleCellClick(x, y);
                        gridEl.appendChild(cell);
                    }
                }
                
                // Render color palette
                this.renderPalette();
            }
            
            renderPalette() {
                const palette = document.getElementById('colorPalette');
                palette.innerHTML = '';
                
                const usedColors = [...new Set(this.sources.map(s => s.color))];
                
                usedColors.forEach((color, index) => {
                    const btn = document.createElement('div');
                    btn.className = 'color-btn';
                    btn.style.background = color;
                    btn.dataset.color = color;
                    
                    if (this.selectedColor === color) {
                        btn.classList.add('selected');
                    }
                    
                    btn.onclick = () => this.selectColor(color);
                    palette.appendChild(btn);
                });
            }
            
            selectColor(color) {
                this.selectedColor = color;
                this.renderPalette();
            }
            
            handleCellClick(x, y) {
                if (this.isComplete) return;
                
                const cell = this.grid[y][x];
                
                // If clicking on a source, select its color
                if (cell && cell.isSource) {
                    this.selectColor(cell.color);
                    return;
                }
                
                // If no color selected, do nothing
                if (!this.selectedColor) return;
                
                // If cell is empty, fill it
                if (!cell) {
                    this.grid[y][x] = {
                        color: this.selectedColor,
                        isSource: false
                    };
                    this.moves++;
                    this.render();
                    this.updateStats();
                    this.checkWin();
                } 
                // If cell is filled (not source), clear it
                else if (!cell.isSource) {
                    this.grid[y][x] = null;
                    this.moves++;
                    this.render();
                    this.updateStats();
                }
            }
            
            checkWin() {
                // Check if all cells are filled
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        if (!this.grid[y][x]) return false;
                    }
                }
                
                // Check if colors form valid paths
                // For simplicity, just check if grid is full for now
                // In a full implementation, you'd verify paths connect sources
                
                this.isComplete = true;
                setTimeout(() => this.showSuccess(), 300);
                return true;
            }
            
            showSuccess() {
                document.getElementById('modalMoves').textContent = this.moves;
                
                // Show reward option every 3 levels
                if (this.level % 3 === 0) {
                    document.getElementById('rewardText').style.display = 'block';
                    document.getElementById('watchAdBtn').style.display = 'block';
                }
                
                document.getElementById('successModal').classList.add('active');
            }
            
            useHint() {
                if (this.hints <= 0) {
                    // Offer to watch ad for hints
                    if (confirm('Out of hints! Watch a short ad to get 2 more hints?')) {
                        this.watchAdForHints();
                    }
                    return;
                }
                
                // Find an empty cell that should be filled
                let hintGiven = false;
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        if (!this.grid[y][x]) {
                            // Flash the cell as a hint
                            const cells = document.querySelectorAll('.cell');
                            const index = y * this.gridSize + x;
                            cells[index].classList.add('hint');
                            setTimeout(() => cells[index].classList.remove('hint'), 1200);
                            
                            this.hints--;
                            this.updateStats();
                            this.saveProgress();
                            hintGiven = true;
                            return;
                        }
                    }
                }
                
                if (!hintGiven) {
                    alert('No hints available for this position!');
                }
            }
            
            watchAdForHints() {
                // Simulate watching an ad
                alert('Ad would play here (5 seconds)...');
                // In production, integrate with ad network
                
                setTimeout(() => {
                    this.hints = Math.min(this.hints + 2, this.maxHints);
                    this.updateStats();
                    this.saveProgress();
                    alert('You earned 2 hints!');
                }, 1000);
            }
            
            reset() {
                this.moves = 0;
                this.generateLevel();
                this.render();
                this.updateStats();
            }
            
            updateStats() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('moves').textContent = this.moves;
                document.getElementById('hints').textContent = this.hints;
                document.getElementById('hintCount').textContent = this.hints;
                
                // Disable hint button if no hints
                document.getElementById('hintBtn').disabled = false;
                
                this.saveProgress();
            }
        }
        
        // Initialize game
        let game;
        window.addEventListener('DOMContentLoaded', () => {
            game = new ColorFlowGame();
            
            // Register service worker for offline play
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('Service Worker registered'))
                    .catch(err => console.log('Service Worker registration failed'));
            }
        });
        
        // Modal functions
        function nextLevel() {
            document.getElementById('successModal').classList.remove('active');
            game.level++;
            game.generateLevel();
            game.render();
            game.updateStats();
            
            // Hide reward options
            document.getElementById('rewardText').style.display = 'none';
            document.getElementById('watchAdBtn').style.display = 'none';
        }
        
        function watchAd() {
            // Simulate ad watching
            alert('Ad would play here...');
            
            // In production, use actual ad network
            // Example: showRewardedVideoAd().then(() => { ... })
            
            game.hints = Math.min(game.hints + 2, game.maxHints);
            game.updateStats();
            nextLevel();
        }
        
        function openSupport() {
            if (confirm('Enjoying Color Flow? Buy me a coffee to support development! â˜•\n\nThis will open PayPal/Ko-fi in a new tab.')) {
                window.open('https://ko-fi.com/maturingminds', '_blank');
            }
        }
    </script>
</body>
</html>